// #define ATTACH_DEBUGGER

using System.Text;
using System;
using System.IO;
using System.Text.RegularExpressions;
using Microsoft.AspNetCore.Razor.Language;
using Microsoft.CodeAnalysis;
using MiniRazor.CodeGen.Utils.Extensions;
using MiniRazor;

namespace MiniRazor.CodeGen
{
    [Generator]
    public partial class TemplateClassGenerator : ISourceGenerator
    {
        private string _rootNamespace = "MiniRazor.GeneratedTemplates";
        private string? _projectDir = null;

        private static readonly string GeneratorVersion =
            typeof(TemplateClassGenerator).Assembly.GetName().Version.ToString(3);

        private static string? TryGetModelTypeName(string code, string className) =>
            Regex.Match(
                    code,
                    $@"\s*{Regex.Escape(className)}\s*:\s*MiniRazor\.TemplateBase<([^\{{]+)>\s*\r?\n",
                    RegexOptions.Multiline, TimeSpan.FromSeconds(1)
                )
                .Groups[1]
                .Value
                .NullIfWhiteSpace();

        private static string? TryGetNamespace(string code) =>
            Regex.Match(
                    code,
                    @"namespace (\S+)",
                    RegexOptions.Multiline, TimeSpan.FromSeconds(1)
                )
                .Groups[1]
                .Value
                .NullIfWhiteSpace();

        private static string RemoveNullableDirectives(string code) =>
            Regex.Replace(
                code,
                @"^\s*#nullable\s+(restore|disable)\s*$", "",
                RegexOptions.Multiline, TimeSpan.FromSeconds(1)
            );

        private static string RemoveLineDirectives(string code) =>
            Regex.Replace(
                code,
                @"^\s*#line\s+.+$", "",
                RegexOptions.Multiline, TimeSpan.FromSeconds(1)
            );

        private void ProcessFile(GeneratorExecutionContext context, string filePath, string accessModifier, string content)
        {
            string? backupNamespace = _rootNamespace;

            // Reconstruct namespace from root-namespace and directory
            if (_projectDir is not null)
            {
                var filePathDir = Path.GetFullPath(Path.GetDirectoryName(filePath));

                // Continue only if file is inside the project dir structure
                if (filePathDir.StartsWith(_projectDir))
                {
                    var relativeNamespace = filePathDir.Substring(_projectDir.Length);

                    if (relativeNamespace.Length > 0)
                        backupNamespace += "." + relativeNamespace;

                    backupNamespace = SanitizeNamespace(backupNamespace);
                }
            }

            // Generate class name from file name
            var className = SanitizeIdentifier(Path.GetFileNameWithoutExtension(filePath));

            var code = Razor.ToCSharp(content, accessModifier, _rootNamespace, backupNamespace, options =>
            {
                options.ConfigureClass((_, node) =>
                {
                    node.ClassName = className;
                });
            });

            // Get model type from the template's base class
            var modelTypeName = TryGetModelTypeName(code, className) ?? "dynamic";

            var @namespace = TryGetNamespace(code);

            // Disable nullability checks on the entire file
            code = RemoveNullableDirectives(code)
                .Insert(0, "#nullable disable" + Environment.NewLine);

            // Remove line mappings
            code = RemoveLineDirectives(code);

            // Add documentation to the class
            code = code.Insert(code.IndexOf($"{accessModifier} partial class", StringComparison.Ordinal), $@"
/// <summary>Template: {filePath}</summary>
/// <remarks>Generated by MiniRazor v{GeneratorVersion} on {DateTimeOffset.Now}.</remarks>
");

            // Extend the template with some additional code
            code = code.Insert(code.IndexOf("public async override", StringComparison.Ordinal), $@"
/// <summary>Renders the template using the specified writer.</summary>
public static async global::System.Threading.Tasks.Task RenderAsync(global::System.IO.TextWriter output, {modelTypeName} model)
{{
    var template = new {className}();
    template.Output = output;
    template.Model = model;

    await template.ExecuteAsync().ConfigureAwait(false);
}}

/// <summary>Renders the template to a string.</summary>
public static async global::System.Threading.Tasks.Task<string> RenderAsync({modelTypeName} model)
{{
    using (var output = new global::System.IO.StringWriter())
    {{
        await RenderAsync(output, model).ConfigureAwait(false);
        return output.ToString();
    }}
}}
");

            context.AddSource(@namespace is not null ? $"{@namespace}.{className}" : className, code);
        }

        /// <inheritdoc />
        public void Execute(GeneratorExecutionContext context)
        {
            _projectDir = context.GetMSBuildProperty("ProjectDir");

            if (_projectDir is not null)
                _projectDir = Path.GetFullPath(_projectDir);

            _rootNamespace = 
                context.GetMSBuildProperty("RootNamespace") ??
                context.Compilation.AssemblyName ??
                _rootNamespace;

            foreach (var file in context.AdditionalFiles)
            {
                var isRazorTemplate = string.Equals(
                    context.AnalyzerConfigOptions.GetOptions(file).TryGetAdditionalFileMetadataValue("IsRazorTemplate"),
                    "true",
                    StringComparison.OrdinalIgnoreCase
                );

                if (!isRazorTemplate)
                    continue;

                var content = file.GetText(context.CancellationToken)?.ToString();

                if (string.IsNullOrWhiteSpace(content))
                    continue;

                var accessModifier = context.AnalyzerConfigOptions.GetOptions(file).TryGetAdditionalFileMetadataValue("AccessModifier");
                if (string.IsNullOrWhiteSpace(accessModifier)) accessModifier = "internal";

                ProcessFile(context, file.Path, accessModifier!, content!);
            }
        }

        /// <inheritdoc />
        public void Initialize(GeneratorInitializationContext context) {
#if DEBUG && ATTACH_DEBUGGER
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                System.Diagnostics.Debugger.Launch();
            }
#endif 
        }
    }

    public partial class TemplateClassGenerator
    {
        private static string SanitizeIdentifier(string symbolName)
        {
            var buffer = new StringBuilder(symbolName);

            // Must start with a letter or an underscore
            if (buffer.Length > 0 && buffer[0] != '_' && !char.IsLetter(buffer[0]))
            {
                buffer.Insert(0, '_');
            }

            // Replace all other prohibited characters with underscores
            for (var i = 0; i < buffer.Length; i++)
            {
                if (buffer[i] != '_' && !char.IsLetterOrDigit(buffer[i]))
                    buffer[i] = '_';
            }

            return buffer.ToString();
        }

    private static string SanitizeNamespace(string symbolName) {
            var buffer = new StringBuilder(symbolName);


            for (var i = 0; i < buffer.Length; i++) {
                // Replace directory separators with dots
                if (buffer[i] == '/' || buffer[i] == '\\')
                    buffer[i] = '.';

                // Replace all other prohibited characters with underscores
                else if (buffer[i] != '_' && buffer[i] != '.' && !char.IsLetterOrDigit(buffer[i]))
                    buffer[i] = '_';
            }

            // Remove duplicated dots
            return Regex.Replace(buffer.ToString(), @"\.\.+", ".").Trim('.');
        }
    }
}